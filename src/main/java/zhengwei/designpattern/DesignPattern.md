# Design Pattern专栏
## 一、设计模式七大原则
### 1.单一职责原则
对于类来说，一个类应该只负责一项职责
1. 降低类的复杂度，一个类只负责一项职责
2. 提高类的可读性，可维护性
3. 降低变更引起的风险
4. 通常情况下，**我们应当遵守单一职责原则**，只有逻辑足够简单，才可以在代码中违反唯一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则
## Future设计模式
异步获取结果，不需要同步等待程序执行完毕返回结果
涉及到的角色
1. Future           - interface     - 代表未来获取结果的一种凭证
2. FutureTask       - interface     - `call()`由我们自己封装实现业务逻辑
3. FutureService    - interface     - 作为Future和FutureTask之间的桥梁
## 不可变对象设计模式
JDk官方的建议：
1. 不要为类属性设置 `setter` 方法
2. 类中所有的属性都要是 `private` 和 `final` 修饰的
3. 不要让子类去重载方法，用 `final` 修饰类
>不可变对象在多线程环境下被访问时的效率要比可变对象中加锁方法( `synchronized` 修饰的方法)高
>因为不可变对象中的属性都是不可变的，无需上锁，而可变对象中需要加锁控制线程之间的数据的安全性，所以效率会低点
* 需要注意的一点是：当不可变对象中有引用类型的变量时，在外部类去get该属性值的时候需要控制下，要么返回该属性值的副本，要么返回该属性值的一个不可变对象
## 线程上下文设计模式
1. ThreadLocal：每个线程的变量都存在自己的内存中，线程间的变量互不干扰，变量与线程一一对应
2. 利用ThreadLocal的特性，把线程中的私有变量保存到ThreadLocal中，就不用对变量加锁，每个线程只操作自己的变量，提高效率
3. 特别注意：如果是使用了线程池的话，那么在每次线程处理完毕之后需要清理ThreadLocal中的变量，否则在下个任务过来的时候，ThreadLocal中的变量将会是上个线程处理任务时的变量，会发生错误
## 门闩设计模式
1. 需要等待特定线程执行完毕之后再去进行接下来的任务，那么在特定线程执行完之前，需要阻塞后面的线程，先执行特定的线程
2. 利用一个计数器来统计特定线程的计算个数，执行完一个特定线程之后计数器加一，直到特定线程执行完毕
## Thread-Pre-Message
1. 来一个任务则开启一个线程去处理它，
2. 不能无节制的启动和销毁线程，创建和销毁线程的代价是比较大的
3. 一般配合线程池来使用
## 生产者-消费者设计模式
1. 生产者生产数据供消费者去消费
2. 消费者消费数据
3. 当消息队列满的时候，生产者则wait；当消息队列不为空时，消费者消费数据