# Netty专题
## Netty程序的大体流程
1. 首先声明两个事件循环组，bossGroup和workerGroup
2. bossGroup主要是接收请求，并不对请求进行处理，bossGroup接到请求后交给workerGroup去处理
3. 创建ServerBootstrap，用于后续的启动服务
4. 往ServerBootstrap中设置事件循环组、channel(管道类型)和处理器，绑定端口和关闭服务的相关设置
5. 在处理器中，我们可以在管道中添加相关处理类
## Netty能够做到的事情
1. 更为底层的http服务器开发，不同于Jetty和Tomcat这些服务器，它没有实现Servlet规范，而是自定义了一套规范
2. socket开发，RPC调度框架(开源项目应用广泛)，Spark底层的通讯组件
3. 支持http的长连接开发，客户端与服务器保持长时间的连接，在长连接下，客户端和服务端可以互传数据，一旦Netty长连接建立完毕，那么客户端和服务端之间的传输就可以是纯粹的数据而没有其他冗余的数据存在
4. 可以自定义协议
## Netty对于长连接WebSocket的支持
### 长连接
客户端与服务器端的链接一旦建立好之后，在没有外部原因的情况下，这个链接是不会断掉的，而且客户端和服务器端就变成了两个对等的实体，客户端与服务器端之间可以互发数据，从而实现服务器端向客户端push的操作。
而且只有在建立长连接的最开始是需要客户端向服务器端发送请求(包括请求头和请求体)，等长连接建立完毕之后，客户端和服务器端在这个长连接基础之上只需要发送真正的数据而不需要发送其他冗余的请求(请求头信息)，节省网络带宽。
长连接是http协议的升级协议，在建立长连接之前，还是会发送标准的http请求，只不过会在请求头中包含WebSocket的一些参数，以告知服务器端建立长连接。
### WebSocket
1. WebSocket是HTML5规范的一部分，为了解决http协议存在的一些不足。http协议是无状态的，是基于请求和响应的一种协议。
2. WebSocket本身是http协议的。
3. WebSocket也可以支持非浏览器的场合。(app和服务器端)服务器端向app推送数据。
### http协议
http协议存在的一些不足。http协议是无状态的，是基于请求和响应的一种协议。所谓的无状态就是相同的客户端向服务端发送一个请求之后再去发送另外一个请求，这两次请求是没有任何关系的，服务器是不会认为这两个请求是同一个客户端发送的；服务端无法追溯到客户端，由此产生cookie和session。<br/>
基于请求和响应模式的，一次请求的产生一定是由客户端发起的，在客户端发送请求之前，客户端与服务器端一定会建立好一个链接，所有的请求都会在此链接之上进行，服务器端收到请求之后进行相应的处理，处理完毕之后服务器就会构造出response对象进行相应。
对于http1.0的时候，一旦客户端与服务器端的请求交互结束之后，这个链接也就被关闭了；在http1.1的时候，增加了一个新的特性 `keep alive` 持续链接即客户端与服务器端保持着这样一个链接，在指定的时间范围之内，如果客户端与服务器端还会发送请求的时候，就会重用这个链接，但是超过时间没有再发送请求，那么这个链接就会被自动的关闭。
服务器端是无法主动向客户端发送消息的。