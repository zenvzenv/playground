package zhengwei.jvm;

/**
 * 探究字节码文件
 * cafe babe 0000 0034 0018 0a00 0400 1409
 * 0003 0015 0700 1607 0017 0100 0161 0100
 * 0149 0100 063c 696e 6974 3e01 0003 2829
 * 5601 0004 436f 6465 0100 0f4c 696e 654e
 * 756d 6265 7254 6162 6c65 0100 124c 6f63
 * 616c 5661 7269 6162 6c65 5461 626c 6501
 * 0004 7468 6973 0100 1b4c 7a68 656e 6777
 * 6569 2f6a 766d 2f54 6573 7442 7974 6543
 * 6f64 653b 0100 0467 6574 4101 0003 2829
 * 4901 0004 7365 7441 0100 0428 4929 5601
 * 000a 536f 7572 6365 4669 6c65 0100 1154
 * 6573 7442 7974 6543 6f64 652e 6a61 7661
 * 0c00 0700 080c 0005 0006 0100 197a 6865
 * 6e67 7765 692f 6a76 6d2f 5465 7374 4279
 * 7465 436f 6465 0100 106a 6176 612f 6c61
 * 6e67 2f4f 626a 6563 7400 2100 0300 0400
 * 0000 0100 0200 0500 0600 0000 0300 0100
 * 0700 0800 0100 0900 0000 3800 0200 0100
 * 0000 0a2a b700 012a 04b5 0002 b100 0000
 * 0200 0a00 0000 0a00 0200 0000 0800 0400
 * 0900 0b00 0000 0c00 0100 0000 0a00 0c00
 * 0d00 0000 0100 0e00 0f00 0100 0900 0000
 * 2f00 0100 0100 0000 052a b400 02ac 0000
 * 0002 000a 0000 0006 0001 0000 000c 000b
 * 0000 000c 0001 0000 0005 000c 000d 0000
 * 0001 0010 0011 0001 0009 0000 003e 0002
 * 0002 0000 0006 2a1b b500 02b1 0000 0002
 * 000a 0000 000a 0002 0000 0010 0005 0011
 * 000b 0000 0016 0002 0000 0006 000c 000d
 * 0000 0000 0006 0005 0006 0001 0001 0012
 * 0000 0002 0013
 * 1.使用javap -verbose命令分析一个字节码文件时，将会分析该字节码文件的魔数、版本号、常量池、类信息，类构造方法和成员变量信息。
 * 2.魔数：所有的.class文件前四个字节魔数，魔数值为固定值，：0xCAFEBABE
 * 3.魔数之后的4个字节时版本信息，前两个字节是次版本号minor version，后俩个字节是主版本号major version，这里是0x0034，换算成十进制
 *   次版本号是0，主版本号是52。该文件是由JDK1.8编译而来，可以使用java -version来验证这一点
 * 4.常量池(constant pool)：紧接着主版本号之后的就是常量池的入口，一个Java类中定义的很多信息都是由常量池来维护和描述的，可以将常量池
 *   看作是class文件的资源池，比如Java中定义的方法与变量信息，都存储在常量池中。常量池中主要存储两类常量：字面量和符号引用。字面量就是
 *   文本字符串，Java中被声明成final的常量值等；而符号引用是如类和接口的全局限定名，字段的名称和描述符，方法的名称和描述符等。
 * 5.常量池的总体结构：Java类所对应的常量池主要由常量池数量和常量池表组成。常量池的数量紧跟主版本号之后，占据两个字节；常量池表紧跟在常量池
 *   数量之后，常量池数组与一般的数组不同的是常量池数组中不同的元素类型、结构是不同的，长度自然也就不同，但是每一种元素的第一个数据都是
 *   u1类型，该字节是个标志位，占据一个字节。JVM在解析常量池时，会根据这个u1类型来获取元素的具体类型。值得注意的是：常量池中元素的个数
 *   =常量池数-1(其中0暂时不使用)，目的是满足某些常量池索引值的数据在特定情况下需要表达“不引用任何一个常量池”的含义；根本原因在于，索引
 *   0也是一个常量(保留常量)，只不过它不位于常量池中，这个常量就对应null值，常量池的索引从1而非0开始。
 * 6.在JVM规范中，每个变量/字段都有描述信息，描述信息主要是描述字段的数据类型、方法的参数列表(包括数量、类型与顺序)与返回值。根据描述
 *   规则，基本数据类型和代表无返回值的void类型都用一个大写字母表示，对象类型使用大写的L加对象的全限定名来表示。为了压缩文件的体积。
 *   对于基本数据类型，JVM都只是用一个大写字母来表示，如下所示：
 *      B -> byte
 *      C -> char
 *      F -> float
 *      I -> int
 *      J -> long
 *      S -> short
 *      Z -> boolean
 *      V -> void
 *      L -> 对象，如：Ljava/lang.Object;
 * 7.对于数组类型来说，每一个维度使用一个前置的[来表示，如int[]表示为[I; String[][]表示为[[Ljava.lang.String;
 * 8.用描述来描述方法时，按照先参数列表后返回值的顺序来描述，参数列表按照严格顺序定义在()之内，
 *   如方法 String getRealNameByIdAndNickName(int id, String nickName){}  表述为：(I,Ljava/lang/String;)Ljava/lang/String;
 *
 * @author zhengwei AKA Sherlock
 * @since 2019/6/6 17:13
 */
public class TestByteCode {
	private int a = 1;

	public int getA() {
		return a;
	}

	public void setA(int a) {
		this.a = a;
	}
}
