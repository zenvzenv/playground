Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# 并发

## 并发工具

### CountDownLatch

#### 主要方法

##### await\(\)

###### 主调线程调用await\(\)方法去等待子线程完成任务

##### countdown\(\)

###### 子线程去调用countdown\(\)方法，将count\(门闩\)减一

#### 初始化时指定count\(门闩\)大小

#### 主调线程会等到count大小为0时，再去执行后去操作

#### 子线程可以并行的去执行，每当子线程执行完先行代码之后需要调用countdown\(\)将count\-1

### CyclicBarrier

#### 主要方法

##### await\(\)

###### 子线程将先行代码执行完毕之后调用await\(\)方法，等待其他线程执行完先行代码

#### 可循环使用，调用reset\(\)之后重置状态

#### 没有主调线程，由各个子线程去控制何时是屏障点

#### 当线程执行到await\(\)处，线程会阻塞，等待其他线程，待其他线程都到达屏障点之后，再一起执行各自的后续操作

### Locks

#### ReentrantLock

##### 主要方法

###### lock\(\)

####### 显示声明加锁

###### unlock\(\)

####### 显示声明释放锁

##### 可重入锁，独占锁，作用与synchronized类似

##### 需要在try\-finally代码块中手动释放锁

#### ReadWriteLock

##### 主要方法

###### readLock\(\)

####### 获取读锁

###### readLock\(\)

####### 获取写锁

###### unlock\(\)

####### 释放锁

##### 可重入读写锁，读读不互斥，读写互斥

##### 需要在try\-finally代码块中手动释放锁

#### StampedLock

##### 主要方法

###### readLock\(\)

####### 获取读锁

###### unlockRead\(int stamped\)

####### 释放读锁，需要指定戳，如果给定的戳不匹配将会报错

###### writeLock\(\)

####### 获取写锁

###### unlockWirte\(int stamped\)

####### 释放写锁，需要指定戳，如果给定的戳不匹配将会报错

###### tryOptimisticRead\(\)

####### 获取乐观读锁，获取一个戳，在下一次读的时候这个戳没有改变将可以直接读取

###### validate\(int stamped\)

####### 判断乐观锁的戳是否被修改过

##### 进化版的读写锁，可以通过乐观锁来提高效率，在获取乐观锁时通过获得一个戳，然后判断这个戳有没有发生改变，如果没有改变则可以直接进行下一次的读，如果发生改变则将乐观锁升级为悲观锁，阻塞住直到获取到读锁

##### 需要再try\-finally代码块中手动release许可证

### Condition

#### 主要方法

##### await\(\)

###### 进入阻塞状态，等待被唤醒，类似于Object\.wait\(\)

##### signal\(\)

###### 随机唤醒一个阻塞状态的线程，类似与Object\.notify\(\)

##### signalAll\(\)

###### 唤醒所有阻塞状态的线程进行锁竞争，类似于Object\.notifyAll\(\)

#### 作用与Object\.wait\(\)和Object\.notify\(\)和Object\.notifyAll\(\)类似

### Semaphore

#### 主要方法

##### acquire\(\)

###### 申请许可证，如果申请不到则会阻塞，进入阻塞队列中

##### release\(\)

###### 释放许可证，把许可证放回去

#### 类似于一个池子，初始化的时候指定池子的大小，每当acquire之后，池子中的permits量减一，realease之后池子中的permits加一，当permits为0时，再有线程申请的时候进入阻塞队列

#### 需要再try\-finally代码块中手动release许可证

### Phaser

#### 主要方法

##### register\(\)

###### 动态注册一个线程进parties

##### arriveAndAwaitAdvance\(\)

###### 等待其他没有arrive的线程，直到所有线程都arrive之后执行后续代码

##### arriveAndDeregister\(\)

###### arrive并注销自己，后续的阶段的parties数量将会减去注销的线程的数量

##### arrive\(\)

###### 告诉其余线程此线程已arrive\(\)，之后继续执行自己剩下来的代码，不会阻塞住，与arriveAndAwaitAdvance\(\)不同

##### awaitAdvance\(int phase\)

###### 如果给定的阶段数和当前阶段数不一致或者Phaser已经终止的话将会立即返回，否则会等待其他线程都arrive后继续执行后续代码

#### 可动态的注册线程也可以指定固定的parties，有点类似与CountDownLatch和CyclicBarrier的组合

### ForkJoin

#### 分而治之

#### 主要方法

##### fork\(\)

### Exchanger

#### 主要方法

##### V r = exchange\(V x\)

###### x代表线程需要发送出去的数据，r代表从别的线程获取到的数据

#### 用于两个线程之间互相交换数据，两个线程会互相等待各自到达交换点\(即exchange\(V\)方法处\)

#### 只支持两个线程之间互换数据，如果超过两个线程互换数据将会出现问题

## 线程池

### Executor
