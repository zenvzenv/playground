Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# 并发

## 并发工具
> collapsed=`true`


### CountDownLatch
> collapsed=`true`


#### 主要方法
> collapsed=`true`


##### await\(\)
> collapsed=`true`


###### 主调线程调用await\(\)方法去等待子线程完成任务

##### countdown\(\)
> collapsed=`true`


###### 子线程去调用countdown\(\)方法，将count\(门闩\)减一

#### 初始化时指定count\(门闩\)大小

#### 主调线程会等到count大小为0时，再去执行后去操作

#### 子线程可以并行的去执行，每当子线程执行完先行代码之后需要调用countdown\(\)将count\-1

### CyclicBarrier
> collapsed=`true`


#### 主要方法
> collapsed=`true`


##### await\(\)
> collapsed=`true`


###### 子线程将先行代码执行完毕之后调用await\(\)方法，等待其他线程执行完先行代码

#### 可循环使用，调用reset\(\)之后重置状态

#### 没有主调线程，由各个子线程去控制何时是屏障点

#### 当线程执行到await\(\)处，线程会阻塞，等待其他线程，待其他线程都到达屏障点之后，再一起执行各自的后续操作

### Locks
> collapsed=`true`


#### ReentrantLock
> collapsed=`true`


##### 主要方法
> collapsed=`true`


###### lock\(\)
> collapsed=`true`


####### 显示声明加锁

###### unlock\(\)
> collapsed=`true`


####### 显示声明释放锁

##### 可重入锁，独占锁，作用与synchronized类似

##### 需要在try\-finally代码块中手动释放锁

#### ReadWriteLock
> collapsed=`true`


##### 主要方法
> collapsed=`true`


###### readLock\(\)
> collapsed=`true`


####### 获取读锁

###### readLock\(\)
> collapsed=`true`


####### 获取写锁

###### unlock\(\)
> collapsed=`true`


####### 释放锁

##### 可重入读写锁，读读不互斥，读写互斥

##### 需要在try\-finally代码块中手动释放锁

#### StampedLock
> collapsed=`true`


##### 主要方法
> collapsed=`true`


###### readLock\(\)
> collapsed=`true`


####### 获取读锁

###### unlockRead\(int stamped\)
> collapsed=`true`


####### 释放读锁，需要指定戳，如果给定的戳不匹配将会报错

###### writeLock\(\)
> collapsed=`true`


####### 获取写锁

###### unlockWirte\(int stamped\)
> collapsed=`true`


####### 释放写锁，需要指定戳，如果给定的戳不匹配将会报错

###### tryOptimisticRead\(\)
> collapsed=`true`


####### 获取乐观读锁，获取一个戳，在下一次读的时候这个戳没有改变将可以直接读取

###### validate\(int stamped\)
> collapsed=`true`


####### 判断乐观锁的戳是否被修改过

##### 进化版的读写锁，可以通过乐观锁来提高效率，在获取乐观锁时通过获得一个戳，然后判断这个戳有没有发生改变，如果没有改变则可以直接进行下一次的读，如果发生改变则将乐观锁升级为悲观锁，阻塞住直到获取到读锁

##### 需要再try\-finally代码块中手动release许可证

### Condition
> collapsed=`true`


#### 主要方法
> collapsed=`true`


##### await\(\)
> collapsed=`true`


###### 进入阻塞状态，等待被唤醒，类似于Object\.wait\(\)

##### signal\(\)
> collapsed=`true`


###### 随机唤醒一个阻塞状态的线程，类似与Object\.notify\(\)

##### signalAll\(\)
> collapsed=`true`


###### 唤醒所有阻塞状态的线程进行锁竞争，类似于Object\.notifyAll\(\)

#### 作用与Object\.wait\(\)和Object\.notify\(\)和Object\.notifyAll\(\)类似

### Semaphore
> collapsed=`true`


#### 主要方法
> collapsed=`true`


##### acquire\(\)
> collapsed=`true`


###### 申请许可证，如果申请不到则会阻塞，进入阻塞队列中

##### release\(\)
> collapsed=`true`


###### 释放许可证，把许可证放回去

#### 类似于一个池子，初始化的时候指定池子的大小，每当acquire之后，池子中的permits量减一，realease之后池子中的permits加一，当permits为0时，再有线程申请的时候进入阻塞队列

#### 需要再try\-finally代码块中手动release许可证

### Phaser
> collapsed=`true`


#### 主要方法
> collapsed=`true`


##### register\(\)
> collapsed=`true`


###### 动态注册一个线程进parties

##### arriveAndAwaitAdvance\(\)
> collapsed=`true`


###### 等待其他没有arrive的线程，直到所有线程都arrive之后执行后续代码

##### arriveAndDeregister\(\)
> collapsed=`true`


###### arrive并注销自己，后续的阶段的parties数量将会减去注销的线程的数量

##### arrive\(\)
> collapsed=`true`


###### 告诉其余线程此线程已arrive\(\)，之后继续执行自己剩下来的代码，不会阻塞住，与arriveAndAwaitAdvance\(\)不同

##### awaitAdvance\(int phase\)
> collapsed=`true`


###### 如果给定的阶段数和当前阶段数不一致或者Phaser已经终止的话将会立即返回，否则会等待其他线程都arrive后继续执行后续代码

#### 可动态的注册线程也可以指定固定的parties，有点类似与CountDownLatch和CyclicBarrier的组合

### ForkJoin
> collapsed=`true`


#### 分而治之

#### 主要方法
> collapsed=`true`


##### fork\(\)

### Exchanger
> collapsed=`true`


#### 主要方法
> collapsed=`true`


##### V r = exchange\(V x\)
> collapsed=`true`


###### x代表线程需要发送出去的数据，r代表从别的线程获取到的数据

#### 用于两个线程之间互相交换数据，两个线程会互相等待各自到达交换点\(即exchange\(V\)方法处\)

#### 只支持两个线程之间互换数据，如果超过两个线程互换数据将会出现问题

## 线程池

### Executor
- NOTE
<pre>线程池的顶级接口</pre>

#### 线程池的顶级接口，只定义了一个无返回值的execute\(Runnable command\)方法

#### 方法

##### void execute\(Runnable command\);

###### 在不久的将来去执行给定的线程

#### ExecutorService

##### 线程池次级接口，继承自Executor，对Executor进行扩展，增加了一些关闭线程池和提交任务的方法

##### 重要方法

###### void shutdown\(\);

####### 关闭线程池，不在接受新的任务，但是已提交的线程会执行完毕

###### List\<Runnable\> shutdownNow\(\);

####### 立即关闭线程池，没有执行完的线程会被终结然后被返回

###### boolean isShutdown\(\);

####### 查看线程池是否以及关闭

###### boolean isTerminated\(\);

####### 查看线程池已经终止，只有调用shutdown\(\)、shutdownNo\(\)之后才有可能为true

###### boolean awaitTermination\(long timeout, TimeUnit unit\)

####### 在指定时间内线程池达到终止状态了才会返回true

###### \<T\> Future\<T\> submit\(Callable\<T\> task\);

####### 执行有返回值的任务，任务的结果为task\.call\(\)的结果

##### AbstractExecutorService

###### ForkJoinPool

####### 分而治之：将一个大任务，拆分成互相独立的小任务，然后将小任务的执行结果合并，从而得到大任务的结果

####### ForkJoinPool中的这些WorkQueue和工作线程ForkJoinWorkerThread并不是一对一的关系，而是随时都有多余ForkJoinWorkerThread数量的WorkQueue元素

####### 而这个ForkJoinPool中的WorkQueue数组中，索引位为非奇数的工作队列用于存储从外部提交到ForkJoinPool中的任务，也就是所谓的submissions queue；

####### 索引位为奇数的工作队列用于存储归并计算过程中等待处理的子任务，也就是task queue。

####### ForkJoinWorkThread

######## 重要属性

######### ForkJoinPool

######### WorkQueue

####### ForkJoinTask

######## 重要方法

######### fork\(\)

########## 将一个任务提交到当前工作线程的工作队列中

######### join\(\)

########## 等待当前线程执行完毕返回结果

######### invoke\(\)

########## 等待当前线程执行完毕返回结果

######## 子类

######### RecursiveAction

########## 无返回值任务

######### RecursiveTask\<T\>

########## 有返回值任务

####### WorkQueue

######## 是ForkJoinPool的内部类，是线程池中每个工作线程对应的工作队列，支持工作窃取

######### 工作窃取就是空闲的工作线程会去别的工作线程的工作队列窃取任务然后执行

####### 主要方法

######## \<T\> ForkJoinTask\<T\> submit\(ForkJoinTask\<T\> task\)

######### 提交一个任务，并将该任务返回，将任务加到当天提交者的任务队列中

######## void execute\(Runnable task\)

######### 提交一个任务，将任务加到当天提交者的任务队列中

###### ThreadPoolExecutor

####### corePoolSize

######## 线程池中核心线程的数量

######## 即使线程是空闲的，也不会结束这些线程的生命周期，除非指定了allowCoreThreadTimeOut

####### maximumPoolSize

######## 线程池中最大的线程数量

####### keepAliveTime

######## 当当前线程池中的活动线程大于核心线程的数量，这个时间是空闲线程的最大存活时间

####### unit

######## 最大存活时间的时间单位

####### workQueue

######## 工作队列，当一个任务过来的时候不是直接交给线程去执行，而是先放入工作队列中，然后线程去队列中去取任务

####### threadFactory

######## 创建工作线程的工厂

####### handler

######## 拒绝策略

##### SchedulerExecutorService

### Executors
