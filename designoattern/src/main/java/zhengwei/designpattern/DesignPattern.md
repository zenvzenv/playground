# Design Pattern专栏
## 一、设计模式七大原则
### 1.单一职责原则
对于类来说，一个类应该只负责一项职责
1. 降低类的复杂度，一个类只负责一项职责
2. 提高类的可读性，可维护性
3. 降低变更引起的风险
4. 通常情况下，**我们应当遵守单一职责原则**，只有逻辑足够简单，才可以在代码中违反唯一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则
## Future设计模式
异步获取结果，不需要同步等待程序执行完毕返回结果
涉及到的角色
1. Future           - interface     - 代表未来获取结果的一种凭证
2. FutureTask       - interface     - `call()`由我们自己封装实现业务逻辑
3. FutureService    - interface     - 作为Future和FutureTask之间的桥梁
## 不可变对象设计模式
JDk官方的建议：
1. 不要为类属性设置 `setter` 方法
2. 类中所有的属性都要是 `private` 和 `final` 修饰的
3. 不要让子类去重载方法，用 `final` 修饰类
>不可变对象在多线程环境下被访问时的效率要比可变对象中加锁方法( `synchronized` 修饰的方法)高
>因为不可变对象中的属性都是不可变的，无需上锁，而可变对象中需要加锁控制线程之间的数据的安全性，所以效率会低点
* 需要注意的一点是：当不可变对象中有引用类型的变量时，在外部类去get该属性值的时候需要控制下，要么返回该属性值的副本，要么返回该属性值的一个不可变对象
## 线程上下文设计模式
1. ThreadLocal：每个线程的变量都存在自己的内存中，线程间的变量互不干扰，变量与线程一一对应
2. 利用ThreadLocal的特性，把线程中的私有变量保存到ThreadLocal中，就不用对变量加锁，每个线程只操作自己的变量，提高效率
3. 特别注意：如果是使用了线程池的话，那么在每次线程处理完毕之后需要清理ThreadLocal中的变量，否则在下个任务过来的时候，ThreadLocal中的变量将会是上个线程处理任务时的变量，会发生错误
## 门闩设计模式
1. 需要等待特定线程执行完毕之后再去进行接下来的任务，那么在特定线程执行完之前，需要阻塞后面的线程，先执行特定的线程
2. 利用一个计数器来统计特定线程的计算个数，执行完一个特定线程之后计数器加一，直到特定线程执行完毕
## Thread-Pre-Message
1. 来一个任务则开启一个线程去处理它，
2. 不能无节制的启动和销毁线程，创建和销毁线程的代价是比较大的
3. 一般配合线程池来使用
## 生产者-消费者设计模式
1. 生产者生产数据供消费者去消费
2. 消费者消费数据
3. 当消息队列满的时候，生产者则wait；当消息队列不为空时，消费者消费数据
## Two-Phase-Termination设计模式
1. 一个线程的生命周期分为两个部分，执行部分和清理资源部分，当线程执行完毕之后，即第二部分对线程的资源进行清理和释放
2. 第二阶段的清理和释放资源一般是在 `finally` 代码块中进行
## Workers Thread

## Active Objects
1. 接收异步消息的主动方法

## 二、设计模式(Decorator)
### 1. 装饰模式
1. 装饰模式又称为包装模式(Wrapper)
2. 装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一种替代方案
3. 装饰模式以对客户端透明的方式动态给一个对象附加上更多的责任。换言之，客户端并不会感觉到对象在装饰前和装饰后有什么不同。
4. 装饰器可以在不创造更多子类的前提下将对象的功能扩展。
5. 装饰模式把客户端的调用委派到被装饰类。装饰模式的关键在于这种扩展完全透明
6. 装饰模式在不必改变原类文件和使用继承的情况下，动态扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象
#### 1.1 装饰模式的角色
* 抽象构建角色(Component)：给出一个抽象接口，以规范准备接收附加责任的对象。->InputStream
* 具体构建角色(Concrete Component)：定义一个将要接收附加责任的类->FileInputStream
* 装饰角色(Decorator)：持有一个构件(Component)对象的引用，并定义一个与抽象构件接口一致的接口->FilterInputStream
* 具体装饰角色(Concrete Decorator)：负责构建对象"贴上"附加的责任->BufferedInputStream
#### 1.2 装饰模式的特点
* 装饰对象和真实对象有相同的接口。这样客户端对象就可以和真实对象以同样的方式和装饰对象进行交互
* 装饰对象包含一个真实对象的引用
* 装饰对象接收所有来自客户端的请求。它把这些请求转发给真实的对象
* 装饰对象可以在转发这些请求以前或之后增加一些额外功能。这样可以确保在运行时，不用修改给定对象的结构就可以	在外部增加附加的功能。在面向对象的设计中，通常时通过继承来实现对给定类的功能扩展