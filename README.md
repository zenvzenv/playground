# playground
## **目的在于平时的学习而写的代码**
### 1.common包
* HttpAPIClient-http请求工具包
* IpUtil-IP格式的互转和IP地址的一些判断
* SysUtils-判断一个对象是否为空
### 2.gc目录---更名为--->jvm目录(下次提交将直接改为jvm)
* TestGC-->学习JVM的时候测试GC的一些代码
* TestClassLoader,TestClassLoader2-->学习JVM中类加载过程时测试的亿写实例代码，有代码的帮助，理解起来会更加的透彻
    > 类的加载过程是:加载->链接->初始化->使用->卸载<br/>
    > 其中链接分为:验证->准备->解析<br/>
    __需要特别注意的是准备和初始化是两个过程__<br/>
    1. 加载：加载是把.class文件加载进JVM之中
    2. 链接：将类与类之间的关系处理好
        1. 验证：校验.class文件的正确性
        2. 准备：为类的**静态变量**分配内存空间，并将其**赋初始值**，在到达初始化之前，类的静态变量知识只是jvm赋予的默认值，而不是真正的用户指定的值
        3. 解析：将类中常量池中寻找类、接口、字段和方法的符号引用替换成直接引用的过程
    3. 初始化：为类的静态变量赋予正确的默认值，就是把链接阶段中的准备阶段的类的静态变量的默认值赋予用户指定的初始值
    4. 使用：
        1. 实例化对象：
            * 为类的新实例分配内存空间，通在堆上分配内存空间
            * 为实例赋予默认值
            * 为实例赋予指定的默认值
                **注意：Java编译器为它编译的每个类都至少生成一个初始化方法。在Java的.class文件中这个实例化方法被称为<init>，针对源代码中的一个构造方法，Java编译器都会产生一个<init>方法**
    5. 卸载：把类的相关信息从内存中剔除<br/>
**值得注意的是：类在准备和初始化阶段中，在执行为静态变量赋值遵循从上到下的顺序执行具体实例参见[TestClassLoader2.java](zhengwei.jvm.TestClassLoader2)**
* 类和接口在加载的时候有一些不同，JVM在初始化一个类时，要求它的全部父类全部初始化完毕，但是这条规则不适用于接口
    1. 初始化一个类时，并不会初始化它所有实现的接口
    2. 在初始化一个接口时，并不会先去初始化它的父接口<br/>
    因此，一个父接口并不会因为它的子接口或实现类初始化而初始化，只有当程序首次使用了特定接口的静态变量时，才会去初始化该接口。
### 3.hdfs包
* HDFSClient-hdfs的客户端
* HDFSIO-hdfs的IO操作，包含往云平台上传文件和下载文件等操作
### 4.LeetCode包
* 是一些平时的LeetCode的刷题代码
* Daily-LeetCode01TwoSum-[两数之和](https://leetcode-cn.com/problems/two-sum/)
* Daily-LeetCode02AddTwoNumbers-[两数相加](https://leetcode-cn.com/problems/add-two-numbers/)
### 5.spark包
* 学习和实验spark一些功能的时候写的一些代码
### 6.unsafe包
* 闲暇时看一些Java关于unsafe的文章时写的一些代码
### 7.algorithm包-算法
#### 自己的一些白话理解
* 1.选择排序，时间复杂度是O(n^2),空间复杂度是O(1),不稳定的一种排序算法，
主要思想是：遍历整个要排序的数组，要是前一个元素大于后一个元素，则调换元素位置，知道数组有序位置
* 2.冒泡排序，时间复杂度是O(n^2),空间复杂度是O(1)，稳定的一种排序，
主要思想：有两层循环，外循环控制着要排序的数组的长度，每完成一次比较，下次要比较的数组长度就会减小一；
内循环控制着数组中元素的比较，如果后一个数大于前一个数就交换位置，大的数就像泡泡一样慢慢的往数组的后面跑去，随着要比较的数组长度减少，数组也逐渐有序。
* 3.插入排序，时间复杂度O(n^2),空间复杂度O(1)，稳定的一种排序算法，
主要思想：插入排序就像玩扑克时往手上接牌一样，刚开始牌比较少，随着牌的增多，我们把牌插入到大小合适的地方。
插入排序同样是有两层循环，第一层循环控制着要排序数组的个数，每循环一次要比较的数组长度加一，每次加的一个元素就是要就进行比较的元素，每次新进的元素要和之前的元素进行比较，直到新进的元素大于前一个元素为止。
插入排序适合样本较小和基本有序的元素排序，理论上效率要比选择排序和冒泡排序要高。
### 8.设计模式
#### 8.1 单例模式
* 这里写了4钟单例模式的写法。
* 1.饿汉式，线程安全，也是生产环境中比较常用的一种写法，比较简单的一种方式。这种方式主要是利用JVM只会加载一个类一次的特性来保证线程安全，当类被加载时，静态变量也会被加载；
有一个缺点：就是不论我们是否用到了这个类的对象，JVM都会去加载这个类的实例。
* 2.懒加载，线程不安全和线程不安全的版本都有，主要时利用synchronized关键字去加锁代码块以达到同步效果。但是效率比较低。
* 3.静态内部类的方式，线程安全，这既达到了懒加载也时线程安全的，主要还是利用JVM只加载一次类的这个特性来保证线程安全。
* 4.枚举的方式，真正意义上的单例模式，线程安全，不会被反序列化，这种方法还要继续深入了解下...
#### 8.2 责任链模式
* 可以参阅JavaEE中的过滤器

#### 8.3 观察者模式
* 观察者模式与责任链模式有些相像，都是利用面向对象的多态的这个特性；都是把每个观察者串联起来执行，但是责任链模式中可以中断链的继续执行，而观察者模式一般不中断链的执行。
* 观察者模式有三个主要角色，1.被观察者，2.观察者，3.事件类，还有一些观察者中对于各种事件的处理逻辑的方法。

**平时学习和工作的一些总结**
---
**zhengwei AKA Sherlock**
---
**闲暇之余会更新哦**
