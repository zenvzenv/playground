package zhengwei.jvm.bytecode;

/**
 * 字节码的执行
 * 栈帧(stack frame):栈帧是一种帮助JVM执行方法的调用与方法的执行的数据结构
 * 栈帧本身是一种数据结构，封装了方法的局部变量表、动态链接信息、方法的返回地址以及操作数栈信息
 * 栈帧是线程私有的，每个线程都对应一个操作栈
 *
 * 符号引用：字节码中会保存依赖类的全限定名
 * 直接引用：在字节码运行期间，JVM会把符号引用转换成依赖类得额直接引用，这里可以理解成指针，一个指针指向了以来的类
 *
 * 有些符号引用在类加载阶段或第一次使用时就会转换成直接引用，这种转换叫做静态转换；
 * 另外一些符号引用则是在每次运行期转换为直接引用，这种转换叫做动态链接，这体现在Java的多态性上。
 *
 * 方法的几个字节码指令
 *  1.invokeinterface：调用接口中的方法(在Java8中，接口中是允许有方法的，要用default关键字标识)，实际上是在运行期决定的，决定到底调用实现该接口的哪个对象的特定方法
 *  2.invokestatic：调用静态方法
 *  3.invokespecial：调用自己的私有方法、构造方法(<init>)以及父类方法
 *  4.invokevirtual：调用虚方法，运行期动态查找的过程
 *  5.invokedynamic：动态调用方法
 *
 * 静态解析的四种情形：
 *  1.静态方法
 *  2.父类方法
 *  3.构造方法
 *  4.私有方法(无法被重写)
 * 以上四种方法被称作非虚方法，它们是在类加载阶段就可以将符号引用转换为直接引用。
 * @author zhengwei AKA Sherlock
 * @since 2019/6/27 12:53
 */
public class TestByteCode4 {
}
/*
	Animal a=new Cat();
	a.sleep();
	a=new Dog();
	a.sleep();
	a=new Tiger();
	a.sleep();
	从字节码的角度来看，a.sleep()调用的都是Animal中的sleep()方法，
	只有在运行期间才会真正的直到调用的具体的实例的方法。
	invokevirtual指令来动态派发执行的具体的方法
 */